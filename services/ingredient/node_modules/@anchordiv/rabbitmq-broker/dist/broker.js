"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageQueueManager = exports.RabbitMQBroker = void 0;
const amqplib_1 = __importDefault(require("amqplib"));
const events_1 = __importDefault(require("events"));
/**
 * RabbitMQBroker: Singleton for managing RabbitMQ connections, channels, and operations.
 */
class RabbitMQBroker {
    constructor() {
        this.connection = null;
        this.channel = null;
        this.eventEmitter = new events_1.default();
    }
    /**
     * Get the singleton instance of RabbitMQBroker.
     * @returns RabbitMQBroker instance.
     */
    static getInstance() {
        if (!RabbitMQBroker.instance) {
            RabbitMQBroker.instance = new RabbitMQBroker();
        }
        return RabbitMQBroker.instance;
    }
    /**
     * Initialize RabbitMQ connection and channel.
     * @param url - RabbitMQ connection URL.
     */
    init(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!url) {
                throw new Error("RabbitMQ connection URL is undefined.");
            }
            try {
                this.connection = yield amqplib_1.default.connect(url.trim());
                this.channel = yield this.connection.createChannel();
                console.log("RabbitMQ connection and channel established.");
                this.eventEmitter.emit("connected");
            }
            catch (error) {
                console.error("Failed to connect to RabbitMQ:", error);
                throw error;
            }
        });
    }
    /**
     * Ensure the channel is initialized.
     */
    ensureChannel() {
        if (!this.channel) {
            throw new Error("RabbitMQ channel is not initialized. Call `init()` first.");
        }
        return this.channel;
    }
    /**
     * Closes RabbitMQ connection and channel.
     */
    closeConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.channel) {
                    yield this.channel.close();
                    this.channel = null;
                }
                if (this.connection) {
                    yield this.connection.close();
                    this.connection = null;
                }
                console.log("RabbitMQ connection closed.");
                this.eventEmitter.emit("disconnected");
            }
            catch (error) {
                console.error("Error while closing RabbitMQ connection:", error);
            }
        });
    }
    /**
     * Assert an exchange.
     * @param exchange - Exchange name.
     * @param type - Exchange type.
     * @param options - Exchange options.
     */
    assertExchange(exchange_1, type_1) {
        return __awaiter(this, arguments, void 0, function* (exchange, type, options = { durable: true }) {
            const channel = this.ensureChannel();
            try {
                yield channel.assertExchange(exchange, type, options);
                console.log(`Exchange asserted: ${exchange}`);
            }
            catch (error) {
                console.error(`Failed to assert exchange: ${exchange}`, error);
                throw error;
            }
        });
    }
    /**
     * Assert a queue.
     * @param queue - Queue name.
     * @param options - Queue options.
     */
    setupQueue(queue_1) {
        return __awaiter(this, arguments, void 0, function* (queue, options = {}) {
            const channel = this.ensureChannel();
            try {
                yield channel.assertQueue(queue, options);
                console.log(`Queue set up: ${queue}`);
            }
            catch (error) {
                console.error(`Failed to set up queue: ${queue}`, error);
                throw error;
            }
        });
    }
    /**
     * Bind a queue to an exchange with a routing key.
     * @param queue - Queue name.
     * @param exchange - Exchange name.
     * @param routingKey - Routing key.
     */
    bindQueue(queue, exchange, routingKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const channel = this.ensureChannel();
            try {
                yield channel.bindQueue(queue, exchange, routingKey);
                console.log(`Queue "${queue}" bound to exchange "${exchange}" with routing key "${routingKey}"`);
            }
            catch (error) {
                console.error(`Failed to bind queue: ${queue}`, error);
                throw error;
            }
        });
    }
    /**
     * Publishes a message to a queue.
     * @param queue - Queue name.
     * @param message - Message to publish.
     * @param options - Publish options.
     */
    publishToQueue(queue_1, message_1) {
        return __awaiter(this, arguments, void 0, function* (queue, message, options = {}) {
            const channel = this.ensureChannel();
            try {
                yield channel.assertQueue(queue, { durable: true });
                channel.sendToQueue(queue, Buffer.isBuffer(message) ? message : Buffer.from(message), options);
                console.log(`Message published to queue: ${queue}`);
            }
            catch (error) {
                console.error("Failed to publish message to queue:", error);
                throw error;
            }
        });
    }
    /**
     * Publishes a message to an exchange.
     * @param exchange - Exchange name.
     * @param routingKey - Routing key.
     * @param message - Message to publish.
     * @param options - Publish options.
     */
    publishToExchange(exchange_1, routingKey_1, message_1) {
        return __awaiter(this, arguments, void 0, function* (exchange, routingKey, message, options = {}) {
            const channel = this.ensureChannel();
            try {
                yield channel.assertExchange(exchange, "topic", { durable: true });
                channel.publish(exchange, routingKey, Buffer.isBuffer(message) ? message : Buffer.from(message), options);
                console.log(`Message published to exchange: ${exchange}`);
            }
            catch (error) {
                console.error("Failed to publish message to exchange:", error);
                throw error;
            }
        });
    }
    /**
     * Consumes messages from a queue.
     * @param queue - Queue name.
     * @param onMessage - Callback to process messages.
     */
    consume(queue, onMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            const channel = this.ensureChannel();
            try {
                yield channel.consume(queue, (msg) => __awaiter(this, void 0, void 0, function* () {
                    if (msg) {
                        try {
                            yield onMessage(msg, channel);
                            channel.ack(msg);
                        }
                        catch (error) {
                            console.error("Error processing message:", error);
                            channel.nack(msg, false, true); // Requeue message
                        }
                    }
                }));
                console.log(`Consumer set up for queue: ${queue}`);
            }
            catch (error) {
                console.error("Failed to set up consumer:", error);
                throw error;
            }
        });
    }
    /**
     * Sets up a dead-letter queue.
     * @param queue - Primary queue name.
     * @param dlx - Dead-letter exchange name.
     * @param dlq - Dead-letter queue name.
     */
    setupDeadLetterQueue(queue, dlx, dlq) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.assertExchange(dlx, "topic");
            yield this.setupQueue(dlq, { durable: true });
            yield this.bindQueue(dlq, dlx, "#");
            yield this.setupQueue(queue, {
                durable: true,
                arguments: { "x-dead-letter-exchange": dlx },
            });
            console.log(`Dead-letter queue (${dlq}) set up for (${queue}).`);
        });
    }
    /**
     * Creates a high-level `MessageQueueManager`.
     * @param config - Queue configuration.
     * @returns A `MessageQueueManager` instance.
     */
    createMessageQueueManager(config) {
        return new MessageQueueManager(config, this);
    }
}
exports.RabbitMQBroker = RabbitMQBroker;
/**
 * High-level manager for queues.
 */
class MessageQueueManager {
    constructor(config, broker) {
        this.config = config;
        this.broker = broker;
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            const { exchange, mainQueue, dlx, dlq, routingKey } = this.config;
            yield this.broker.setupDeadLetterQueue(mainQueue, dlx, dlq);
            yield this.broker.assertExchange(exchange, "topic");
            yield this.broker.setupQueue(mainQueue, {
                durable: true,
                arguments: { "x-dead-letter-exchange": dlx },
            });
            yield this.broker.bindQueue(mainQueue, exchange, routingKey);
        });
    }
    processMainQueue(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.broker.consume(this.config.mainQueue, handler);
        });
    }
    processDLQ(handler) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.broker.consume(this.config.dlq, handler);
        });
    }
}
exports.MessageQueueManager = MessageQueueManager;
exports.default = RabbitMQBroker;
